<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>MiniCraft - WebGL</title>
<style>
  :root {
    color-scheme: dark;
  }
  body {
    margin: 0;
    background: #111;
    color: #e6e6e6;
    font-family: "Trebuchet MS", "Segoe UI", sans-serif;
    display: flex;
    justify-content: center;
  }
  #wrap {
    max-width: 980px;
    width: 100%;
    padding: 12px 16px 20px;
  }
  h1 {
    margin: 4px 0 8px;
    font-size: 22px;
    letter-spacing: 1px;
    text-transform: uppercase;
  }
  #hint {
    font-size: 12px;
    color: #cfc28a;
    background: #2a2418;
    border: 2px solid #4c3f20;
    padding: 6px 8px;
    box-shadow: inset 0 0 0 2px #1b160b;
  }
  #canvasWrap {
    position: relative;
    margin: 8px auto;
    width: 960px;
    height: 540px;
    border: 4px solid #3b2f1a;
    box-shadow: inset 0 0 0 2px #1b1408, 0 6px 0 #0e0b05;
    background: #000;
  }
  canvas {
    display: block;
    width: 960px;
    height: 540px;
    image-rendering: pixelated;
  }
  #overlay {
    pointer-events: none;
    position: absolute;
    inset: 0;
  }
  #crosshair {
    position: absolute;
    left: 50%;
    top: 50%;
    width: 12px;
    height: 12px;
    margin-left: -6px;
    margin-top: -6px;
  }
  #crosshair::before,
  #crosshair::after {
    content: "";
    position: absolute;
    background: rgba(255, 255, 255, 0.8);
  }
  #crosshair::before {
    left: 5px;
    top: 0;
    width: 2px;
    height: 12px;
  }
  #crosshair::after {
    left: 0;
    top: 5px;
    width: 12px;
    height: 2px;
  }
  #hud {
    display: flex;
    justify-content: space-between;
    font-size: 13px;
    margin: 6px 2px 8px;
    font-family: "Courier New", monospace;
  }
  .swatch {
    display: inline-block;
    width: 12px;
    height: 12px;
    border: 1px solid #000;
    margin-right: 6px;
    vertical-align: middle;
  }
  #ui {
    display: flex;
    gap: 12px;
    margin-top: 10px;
    flex-wrap: wrap;
  }
  .panel {
    background: #1f1a12;
    border: 2px solid #4c3f20;
    box-shadow: inset 0 0 0 2px #120f09;
    padding: 10px 12px;
    flex: 1 1 280px;
  }
  .panel-title {
    font-size: 13px;
    font-weight: bold;
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: #e8d9a6;
  }
  .inventory-grid {
    display: grid;
    grid-template-columns: repeat(2, minmax(120px, 1fr));
    gap: 8px;
  }
  .inv-slot {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 6px;
    border: 2px solid #3b2f1a;
    background: #14110c;
    font-size: 12px;
  }
  .inv-slot.selected {
    border-color: #9fb9ff;
    background: #1f2433;
  }
  .inv-name {
    flex: 1 1 auto;
  }
  .inv-count {
    font-variant-numeric: tabular-nums;
    font-weight: bold;
  }
  .inv-swatch {
    width: 14px;
    height: 14px;
  }
  .crafting-row {
    display: flex;
    align-items: center;
    gap: 10px;
    margin: 6px 0;
  }
  .craft-item {
    display: flex;
    align-items: center;
    gap: 6px;
    background: #14110c;
    border: 2px solid #3b2f1a;
    padding: 6px 8px;
    font-size: 12px;
  }
  .craft-arrow {
    color: #9fb9ff;
    font-size: 16px;
  }
  .craft-hint {
    font-size: 11px;
    color: #b9b09a;
  }
</style>
</head>
<body>
<div id="wrap">
  <h1>MiniCraft</h1>
  <div id="hint">Move: WASD / arrows, Fly: Space / Shift, Look: mouse drag or click to lock, Mine: left click, Place: right click, Select: 1-5</div>
  <div id="canvasWrap">
    <canvas id="game" width="960" height="540"></canvas>
    <div id="overlay"><div id="crosshair"></div></div>
  </div>
  <div id="hud">
    <div>Selected: <span id="selectedName">Grass</span></div>
    <div>Block: <span id="selectedSwatch" class="swatch"></span></div>
  </div>
  <div id="ui">
    <div class="panel" id="inventoryPanel">
      <div class="panel-title">Inventory</div>
      <div id="inventoryGrid" class="inventory-grid">
        <div class="inv-slot" data-block="1">
          <span class="swatch inv-swatch" data-block="1"></span>
          <span class="inv-name">Grass</span>
          <span class="inv-count" id="inv-1">0</span>
        </div>
        <div class="inv-slot" data-block="2">
          <span class="swatch inv-swatch" data-block="2"></span>
          <span class="inv-name">Dirt</span>
          <span class="inv-count" id="inv-2">0</span>
        </div>
        <div class="inv-slot" data-block="3">
          <span class="swatch inv-swatch" data-block="3"></span>
          <span class="inv-name">Stone</span>
          <span class="inv-count" id="inv-3">0</span>
        </div>
        <div class="inv-slot" data-block="4">
          <span class="swatch inv-swatch" data-block="4"></span>
          <span class="inv-name">Wood</span>
          <span class="inv-count" id="inv-4">0</span>
        </div>
        <div class="inv-slot" data-block="5">
          <span class="swatch inv-swatch" data-block="5"></span>
          <span class="inv-name">Leaves</span>
          <span class="inv-count" id="inv-5">0</span>
        </div>
      </div>
    </div>
    <div class="panel" id="craftingPanel">
      <div class="panel-title">Crafting</div>
      <div class="crafting-row">
        <div class="craft-item">
          <span class="swatch inv-swatch" data-block="4"></span>
          <span>Wood x2</span>
        </div>
        <div class="craft-arrow">â†’</div>
        <div class="craft-item">
          <span class="swatch inv-swatch" data-block="5"></span>
          <span>Leaves x1</span>
        </div>
      </div>
      <div class="craft-hint">Collect materials to craft (display only).</div>
    </div>
  </div>
</div>
<script>
(() => {
  const canvas = document.getElementById('game');
  const gl = canvas.getContext('webgl', { antialias: false, alpha: false });
  if (!gl) {
    alert('WebGL not supported.');
    return;
  }

  const WORLD_W = 64;
  const WORLD_H = 32;
  const WORLD_D = 64;
  const MAX_RAY = 8;

  const blocks = [
    { name: 'Air', color: [0, 0, 0] },
    { name: 'Grass', color: [0.37, 0.68, 0.23] },
    { name: 'Dirt', color: [0.55, 0.34, 0.14] },
    { name: 'Stone', color: [0.56, 0.56, 0.56] },
    { name: 'Wood', color: [0.64, 0.41, 0.17] },
    { name: 'Leaves', color: [0.24, 0.55, 0.24] },
  ];

  const world = new Uint8Array(WORLD_W * WORLD_H * WORLD_D);

  function idx(x, y, z) {
    return x + WORLD_W * (z + WORLD_D * y);
  }
  function inBounds(x, y, z) {
    return x >= 0 && x < WORLD_W && y >= 0 && y < WORLD_H && z >= 0 && z < WORLD_D;
  }
  function getBlock(x, y, z) {
    if (!inBounds(x, y, z)) return 0;
    return world[idx(x, y, z)];
  }
  function setBlock(x, y, z, val) {
    if (inBounds(x, y, z)) world[idx(x, y, z)] = val;
  }
  function clamp(val, min, max) {
    return Math.max(min, Math.min(max, val));
  }

  function generateWorld() {
    const base = Math.floor(WORLD_H * 0.45);
    for (let x = 0; x < WORLD_W; x++) {
      for (let z = 0; z < WORLD_D; z++) {
        const hill = Math.sin(x * 0.2) * 2 + Math.cos(z * 0.2) * 2;
        const jitter = (Math.random() - 0.5) * 3;
        const h = clamp(Math.floor(base + hill + jitter), 6, WORLD_H - 4);
        for (let y = 0; y < WORLD_H; y++) {
          if (y === h) setBlock(x, y, z, 1);
          else if (y > h && y < h + 3) setBlock(x, y, z, 2);
          else if (y >= h + 3) setBlock(x, y, z, 3);
        }
        if (Math.random() < 0.04 && h > 6 && x > 2 && z > 2 && x < WORLD_W - 3 && z < WORLD_D - 3) {
          setBlock(x, h - 1, z, 4);
          setBlock(x, h - 2, z, 4);
          setBlock(x, h - 3, z, 4);
          for (let dy = -5; dy <= -3; dy++) {
            for (let dx = -2; dx <= 2; dx++) {
              for (let dz = -2; dz <= 2; dz++) {
                if (Math.abs(dx) + Math.abs(dz) + Math.abs(dy + 4) < 5) {
                  setBlock(x + dx, h + dy, z + dz, 5);
                }
              }
            }
          }
        }
      }
    }
  }

  generateWorld();

  const inventoryCounts = new Array(blocks.length).fill(0);
  inventoryCounts[1] = 8;
  inventoryCounts[2] = 8;
  inventoryCounts[3] = 6;
  inventoryCounts[4] = 4;
  inventoryCounts[5] = 4;

  let selected = 1;
  const selectedName = document.getElementById('selectedName');
  const selectedSwatch = document.getElementById('selectedSwatch');
  const inventorySlots = Array.from(document.querySelectorAll('.inv-slot'));
  const swatches = Array.from(document.querySelectorAll('.inv-swatch'));

  function updateInventoryUI() {
    for (let i = 1; i < blocks.length; i++) {
      const countEl = document.getElementById(`inv-${i}`);
      if (countEl) countEl.textContent = inventoryCounts[i];
    }
    inventorySlots.forEach((slot) => {
      const id = Number(slot.dataset.block);
      slot.classList.toggle('selected', id === selected);
    });
  }
  function setSelected(id) {
    selected = id;
    selectedName.textContent = blocks[id].name;
    selectedSwatch.style.background = colorToCss(blocks[id].color);
    updateInventoryUI();
  }
  function colorToCss(rgb) {
    return `rgb(${Math.floor(rgb[0] * 255)}, ${Math.floor(rgb[1] * 255)}, ${Math.floor(rgb[2] * 255)})`;
  }
  swatches.forEach((swatch) => {
    const id = Number(swatch.dataset.block);
    if (blocks[id]) swatch.style.background = colorToCss(blocks[id].color);
  });
  setSelected(1);

  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.code)) {
      e.preventDefault();
    }
    keys.add(e.code);
    if (e.code.startsWith('Digit')) {
      const num = Number(e.code.replace('Digit', ''));
      if (num >= 1 && num <= 5) setSelected(num);
    }
  });
  window.addEventListener('keyup', (e) => keys.delete(e.code));

  let dragging = false;
  let dragButton = 0;
  let dragMoved = 0;
  let lastMouse = { x: 0, y: 0 };
  const sensitivity = 0.0024;

  canvas.addEventListener('mousedown', (e) => {
    if (document.pointerLockElement === canvas) {
      handleClick(e.button);
      return;
    }
    dragging = true;
    dragButton = e.button;
    dragMoved = 0;
    lastMouse.x = e.clientX;
    lastMouse.y = e.clientY;
  });
  window.addEventListener('mouseup', (e) => {
    if (dragging && dragMoved < 4) {
      handleClick(e.button);
    }
    dragging = false;
  });
  window.addEventListener('mousemove', (e) => {
    if (document.pointerLockElement === canvas) {
      camera.yaw -= e.movementX * sensitivity;
      camera.pitch -= e.movementY * sensitivity;
      clampPitch();
      return;
    }
    if (!dragging) return;
    const dx = e.clientX - lastMouse.x;
    const dy = e.clientY - lastMouse.y;
    lastMouse.x = e.clientX;
    lastMouse.y = e.clientY;
    dragMoved += Math.abs(dx) + Math.abs(dy);
    camera.yaw -= dx * sensitivity;
    camera.pitch -= dy * sensitivity;
    clampPitch();
  });

  canvas.addEventListener('click', () => {
    canvas.requestPointerLock();
  });
  canvas.addEventListener('contextmenu', (e) => e.preventDefault());

  function clampPitch() {
    camera.pitch = clamp(camera.pitch, -1.45, 1.45);
  }

  const camera = {
    x: WORLD_W * 0.5,
    y: WORLD_H * 0.65,
    z: WORLD_D * 0.5,
    yaw: Math.PI * 0.75,
    pitch: -0.2,
  };

  function normalize(v) {
    const len = Math.hypot(v[0], v[1], v[2]) || 1;
    return [v[0] / len, v[1] / len, v[2] / len];
  }
  function cross(a, b) {
    return [
      a[1] * b[2] - a[2] * b[1],
      a[2] * b[0] - a[0] * b[2],
      a[0] * b[1] - a[1] * b[0],
    ];
  }
  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function mat4Perspective(fov, aspect, near, far) {
    const f = 1 / Math.tan(fov / 2);
    const nf = 1 / (near - far);
    return [
      f / aspect, 0, 0, 0,
      0, f, 0, 0,
      0, 0, (far + near) * nf, -1,
      0, 0, (2 * far * near) * nf, 0
    ];
  }
  function mat4LookAt(eye, target, up) {
    const z = normalize([eye[0] - target[0], eye[1] - target[1], eye[2] - target[2]]);
    const x = normalize(cross(up, z));
    const y = cross(z, x);
    return [
      x[0], y[0], z[0], 0,
      x[1], y[1], z[1], 0,
      x[2], y[2], z[2], 0,
      -dot(x, eye), -dot(y, eye), -dot(z, eye), 1
    ];
  }

  const vertexSrc = `
    attribute vec3 aPos;
    attribute vec3 aNormal;
    attribute vec3 aColor;
    uniform mat4 uProj;
    uniform mat4 uView;
    varying vec3 vColor;
    void main() {
      vec3 lightDir = normalize(vec3(0.4, 0.8, 0.2));
      float light = max(dot(aNormal, lightDir), 0.15);
      vColor = aColor * (0.5 + light * 0.7);
      gl_Position = uProj * uView * vec4(aPos, 1.0);
    }
  `;
  const fragmentSrc = `
    precision mediump float;
    varying vec3 vColor;
    void main() {
      gl_FragColor = vec4(vColor, 1.0);
    }
  `;

  function compileShader(type, src) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }
  function createProgram(vs, fs) {
    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(program));
      return null;
    }
    return program;
  }

  const vs = compileShader(gl.VERTEX_SHADER, vertexSrc);
  const fs = compileShader(gl.FRAGMENT_SHADER, fragmentSrc);
  const program = createProgram(vs, fs);

  const attribs = {
    pos: gl.getAttribLocation(program, 'aPos'),
    normal: gl.getAttribLocation(program, 'aNormal'),
    color: gl.getAttribLocation(program, 'aColor'),
  };
  const uniforms = {
    proj: gl.getUniformLocation(program, 'uProj'),
    view: gl.getUniformLocation(program, 'uView'),
  };

  const buffer = gl.createBuffer();
  let vertexCount = 0;

  const cubeFaces = [
    { n: [1, 0, 0], v: [[1,0,0],[1,1,0],[1,1,1],[1,0,1]] },
    { n: [-1,0,0], v: [[0,0,1],[0,1,1],[0,1,0],[0,0,0]] },
    { n: [0,1,0], v: [[0,1,1],[1,1,1],[1,1,0],[0,1,0]] },
    { n: [0,-1,0], v: [[0,0,0],[1,0,0],[1,0,1],[0,0,1]] },
    { n: [0,0,1], v: [[1,0,1],[1,1,1],[0,1,1],[0,0,1]] },
    { n: [0,0,-1], v: [[0,0,0],[0,1,0],[1,1,0],[1,0,0]] },
  ];

  function rebuildMesh() {
    const data = [];
    for (let y = 0; y < WORLD_H; y++) {
      for (let z = 0; z < WORLD_D; z++) {
        for (let x = 0; x < WORLD_W; x++) {
          const type = getBlock(x, y, z);
          if (type === 0) continue;
          for (const face of cubeFaces) {
            const nx = face.n[0];
            const ny = face.n[1];
            const nz = face.n[2];
            if (getBlock(x + nx, y + ny, z + nz) !== 0) continue;
            const color = blocks[type].color;
            const v = face.v;
            const positions = [
              v[0], v[1], v[2],
              v[0], v[2], v[3],
            ];
            for (const quad of positions) {
              for (const pt of quad) {
                data.push(
                  x + pt[0], y + pt[1], z + pt[2],
                  face.n[0], face.n[1], face.n[2],
                  color[0], color[1], color[2]
                );
              }
            }
          }
        }
      }
    }
    vertexCount = data.length / 9;
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
  }

  rebuildMesh();

  function raycast(origin, dir, maxDist) {
    let x = Math.floor(origin[0]);
    let y = Math.floor(origin[1]);
    let z = Math.floor(origin[2]);

    let stepX = dir[0] > 0 ? 1 : -1;
    let stepY = dir[1] > 0 ? 1 : -1;
    let stepZ = dir[2] > 0 ? 1 : -1;

    const tDeltaX = dir[0] === 0 ? 1e9 : Math.abs(1 / dir[0]);
    const tDeltaY = dir[1] === 0 ? 1e9 : Math.abs(1 / dir[1]);
    const tDeltaZ = dir[2] === 0 ? 1e9 : Math.abs(1 / dir[2]);

    const distX = stepX > 0 ? (x + 1 - origin[0]) : (origin[0] - x);
    const distY = stepY > 0 ? (y + 1 - origin[1]) : (origin[1] - y);
    const distZ = stepZ > 0 ? (z + 1 - origin[2]) : (origin[2] - z);

    let tMaxX = tDeltaX * distX;
    let tMaxY = tDeltaY * distY;
    let tMaxZ = tDeltaZ * distZ;

    let prev = null;
    let traveled = 0;

    for (let i = 0; i < 256; i++) {
      if (!inBounds(x, y, z)) break;
      const block = getBlock(x, y, z);
      if (block !== 0) {
        return { hit: true, x, y, z, prev };
      }
      prev = { x, y, z };
      if (tMaxX < tMaxY) {
        if (tMaxX < tMaxZ) {
          x += stepX;
          traveled = tMaxX;
          tMaxX += tDeltaX;
        } else {
          z += stepZ;
          traveled = tMaxZ;
          tMaxZ += tDeltaZ;
        }
      } else {
        if (tMaxY < tMaxZ) {
          y += stepY;
          traveled = tMaxY;
          tMaxY += tDeltaY;
        } else {
          z += stepZ;
          traveled = tMaxZ;
          tMaxZ += tDeltaZ;
        }
      }
      if (traveled > maxDist) break;
    }
    return { hit: false };
  }

  function handleClick(button) {
    const dir = [
      Math.sin(camera.yaw) * Math.cos(camera.pitch),
      Math.sin(camera.pitch),
      Math.cos(camera.yaw) * Math.cos(camera.pitch),
    ];
    const hit = raycast([camera.x, camera.y, camera.z], dir, MAX_RAY);
    if (!hit.hit) return;
    if (button === 0) {
      const mined = getBlock(hit.x, hit.y, hit.z);
      if (mined !== 0) {
        setBlock(hit.x, hit.y, hit.z, 0);
        inventoryCounts[mined] += 1;
        updateInventoryUI();
        rebuildMesh();
      }
    } else if (button === 2) {
      if (!hit.prev) return;
      if (inventoryCounts[selected] <= 0) return;
      if (getBlock(hit.prev.x, hit.prev.y, hit.prev.z) === 0) {
        setBlock(hit.prev.x, hit.prev.y, hit.prev.z, selected);
        inventoryCounts[selected] -= 1;
        updateInventoryUI();
        rebuildMesh();
      }
    }
  }

  function update(dt) {
    const moveSpeed = 8;
    const riseSpeed = 6;

    const forward = normalize([Math.sin(camera.yaw), 0, Math.cos(camera.yaw)]);
    const right = normalize([Math.cos(camera.yaw), 0, -Math.sin(camera.yaw)]);

    let moveX = 0;
    let moveZ = 0;
    let moveY = 0;

    if (keys.has('KeyW') || keys.has('ArrowUp')) moveZ += 1;
    if (keys.has('KeyS') || keys.has('ArrowDown')) moveZ -= 1;
    if (keys.has('KeyA') || keys.has('ArrowLeft')) moveX -= 1;
    if (keys.has('KeyD') || keys.has('ArrowRight')) moveX += 1;
    if (keys.has('Space')) moveY += 1;
    if (keys.has('ShiftLeft') || keys.has('ShiftRight')) moveY -= 1;

    const moveLen = Math.hypot(moveX, moveZ) || 1;
    moveX /= moveLen;
    moveZ /= moveLen;

    camera.x += (forward[0] * moveZ + right[0] * moveX) * moveSpeed * dt;
    camera.z += (forward[2] * moveZ + right[2] * moveX) * moveSpeed * dt;
    camera.y += moveY * riseSpeed * dt;

    camera.x = clamp(camera.x, 1, WORLD_W - 2);
    camera.y = clamp(camera.y, 2, WORLD_H - 2);
    camera.z = clamp(camera.z, 1, WORLD_D - 2);
  }

  function render() {
    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(0.47, 0.76, 1.0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const aspect = canvas.width / canvas.height;
    const proj = mat4Perspective(Math.PI / 3.4, aspect, 0.1, 140);
    const dir = [
      Math.sin(camera.yaw) * Math.cos(camera.pitch),
      Math.sin(camera.pitch),
      Math.cos(camera.yaw) * Math.cos(camera.pitch),
    ];
    const view = mat4LookAt(
      [camera.x, camera.y, camera.z],
      [camera.x + dir[0], camera.y + dir[1], camera.z + dir[2]],
      [0, 1, 0]
    );

    gl.useProgram(program);
    gl.uniformMatrix4fv(uniforms.proj, false, proj);
    gl.uniformMatrix4fv(uniforms.view, false, view);

    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.vertexAttribPointer(attribs.pos, 3, gl.FLOAT, false, 36, 0);
    gl.vertexAttribPointer(attribs.normal, 3, gl.FLOAT, false, 36, 12);
    gl.vertexAttribPointer(attribs.color, 3, gl.FLOAT, false, 36, 24);
    gl.enableVertexAttribArray(attribs.pos);
    gl.enableVertexAttribArray(attribs.normal);
    gl.enableVertexAttribArray(attribs.color);

    gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
  }

  let last = performance.now();
  function loop(ts) {
    const dt = Math.min(0.04, (ts - last) / 1000);
    last = ts;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
